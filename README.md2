# Final SQL Project

## Step 1 – Business Domain

The project analyzes global AI-related job postings.

Each record represents a job posting published by a company in a specific year and geographic location.

The dataset includes country, region, and city information, which enables geography-based analysis of AI adoption, employment trends, and automation risk.


## Step 2 – Identify Entities & Business Tables

Based on the business domain, the dataset can be decomposed into the following core business entities:

 ### Job_Posting 
  Central fact table. Each record represents a single AI-related job posting published by a company in a specific year and location.

 ### Company
  Represents companies that publish job postings.
  One company can have multiple job postings.

 ### Location 
  Represents the geographic location of a job posting, including country, region, and city.
  Enables geographic and spatial analysis.

 ### Time
  Represents the temporal dimension of the job posting, currently at the year level, enabling trend analysis over time.

 ### Job / AI Characteristics
  Represents AI-related attributes such as job category, automation risk, or skill classification.


## Step 3 – Database and Schema Setup

A dedicated PostgreSQL database was created to isolate the project from other environments and ensure reproducibility.
Within the database, a separate "analytics" schema is used to store all project tables. The "public" schema is not used.






job_postings
---------------
job_id (PK)

-- Foreign Keys
city_id (FK → cities.city_id)
company_id (FK → companies.company_id)
time_id (FK → time_dim.time_id)

-- Job attributes
job_title
seniority_level
salary_usd
ai_mentioned
ai_intensity_score
automation_risk_score
reskilling_required
industry_ai_adoption_stage




Regions were kept as an attribute of cities rather than a separate table to reduce model complexity, as region-level geometry was not required for the analysis.


The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!